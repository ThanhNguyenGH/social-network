files: [
    {
      url:      { type: String, required: true },
      name:     { type: String },
      mimeType: { type: String },
      size:     { type: Number }
    }
  ],

  /* Comment */
.comment-section .comment-content {
    margin-left: 40px;
  }
  .comment-section .comment-list > div {
    border-bottom: 1px solid #e5e7eb;
    padding-bottom: 8px;
    margin-bottom: 8px;
  }
.comment-section .comment-content {
      display: block;
      margin-top: 8px; 
      margin-bottom: 4px; 
      margin-left: 40px; 
    }
    .comment-section .comment-time {
      display: block;
      margin-left: 40px;
      margin-top: 4px;
    }
    .comment-section .edit-label {
      margin-left: 8px; 
    }
    .comment-section .comment-list > div {
      border-bottom: 1px solid #e5e7eb; 
      padding-bottom: 8px;
      margin-bottom: 12px;
    }

 // const messages = await Message.find({
      //   $or: [
      //     { sender: new mongoose.Types.ObjectId(userId), receiver: new mongoose.Types.ObjectId(otherUserId) },
      //     { sender: new mongoose.Types.ObjectId(otherUserId), receiver: new mongoose.Types.ObjectId(userId) }
      //   ]
      // })
      //   .populate('sender', 'username avatar')
      //   .populate('receiver', 'username avatar')
      //   .sort({ createdAt: 1 })
      //   .limit(50);
  
  //chatController:
  const mongoose = require('mongoose');
const Message = require('../models/Message');
const User = require('../models/User');
const redisClient = require('../config/redis');
const s3 = require('../config/backblaze');
const cloudinary = require('../config/cloudinary');
const multer = require('multer');
const path = require('path');
const { uploadMedia, uploadFiles } = require('../utils/uploadMedia2');

// Middleware để xử lý cả media và file upload
const uploadMiddleware = (req, res, next) => {
  uploadMedia(req, res, (err) => {
    if (err instanceof multer.MulterError || err) {
      return res.status(400).json({ success: false, error: err.message || 'Lỗi upload media' });
    }
    uploadFiles(req, res, (err) => {
      if (err instanceof multer.MulterError || err) {
        return res.status(400).json({ success: false, error: err.message || 'Lỗi upload file' });
      }
      next();
    });
  });
};

const chatController = {
  getChatPage: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        console.error('Session user not found');
        return res.status(401).render('pages/error', {
          message: 'Vui lòng đăng nhập để truy cập trang chat',
          layout: 'layouts/main'
        });
      }
      const userId = req.session.user._id;
      if (!mongoose.Types.ObjectId.isValid(userId)) {
        console.error('Invalid userId:', userId);
        return res.status(400).render('pages/error', {
          message: 'ID người dùng không hợp lệ',
          layout: 'layouts/main'
        });
      }
      console.log('Fetching friends for userId:', userId);
      const friends = await User.find({ _id: { $ne: userId } })
        .select('username avatar')
        .sort({ username: 1 })
        .lean();

      console.log('Fetching unread counts for userId:', userId);
      const unreadCounts = await Message.aggregate([
        {
          $match: {
            receiver: new mongoose.Types.ObjectId(userId),
            isRead: false
          }
        },
        {
          $group: {
            _id: '$sender',
            count: { $sum: 1 }
          }
        }
      ]);

      const unreadMap = {};
      unreadCounts.forEach(item => {
        unreadMap[item._id.toString()] = item.count;
      });

      res.render('pages/chat', {
        title: 'Chat',
        userId,
        friends,
        unreadMap,
        csrfToken: res.locals.csrfToken
      });
    } catch (error) {
      console.error('Error loading chat page:', error.stack);
      res.status(500).render('pages/error', {
        message: 'Không thể tải trang chat',
        layout: 'layouts/main'
      });
    }
  },

  getMessagesWithUser: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
      }
      const userId = req.session.user._id;
      const otherUserId = req.params.userId;
      if (!mongoose.Types.ObjectId.isValid(userId) || !mongoose.Types.ObjectId.isValid(otherUserId)) {
        console.error('Invalid userId or otherUserId:', { userId, otherUserId });
        return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
      }

      const redisKey = `chat:${[userId, otherUserId].sort().join(':')}`;
      const cached = await redisClient.get(redisKey);
      if (cached) {
        return res.json({
          success: true,
          messages: JSON.parse(cached)
        });
      }

      const messages = await Message.find({
        $or: [
          { sender: new mongoose.Types.ObjectId(userId), receiver: new mongoose.Types.ObjectId(otherUserId) },
          { sender: new mongoose.Types.ObjectId(otherUserId), receiver: new mongoose.Types.ObjectId(userId) }
        ]
      })
        .populate('sender', 'username avatar')
        .populate('receiver', 'username avatar')
        .sort({ createdAt: 1 })
        .limit(50);

      await redisClient.setEx(redisKey, 60, JSON.stringify(messages));

      res.json({ success: true, messages });
    } catch (error) {
      console.error('Error fetching messages:', error.stack);
      res.status(500).json({ success: false, error: 'Không thể lấy tin nhắn' });
    }
  },

  sendMessage: [
    uploadMiddleware,
    async (req, res) => {
      try {
        if (!req.session.user || !req.session.user._id) {
          return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
        }
        const { receiverId, content } = req.body;
        const senderId = req.session.user._id;

        if (!mongoose.Types.ObjectId.isValid(senderId) || !mongoose.Types.ObjectId.isValid(receiverId)) {
          console.error('Invalid senderId or receiverId:', { senderId, receiverId });
          return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
        }

        // Kiểm tra ít nhất phải có content hoặc file
        if (
          (!content || content.trim() === '') &&
          (!req.files || req.files.length === 0)
        ) {
          return res.status(400).json({ success: false, error: 'Phải cung cấp nội dung hoặc file' });
        }

        // Xử lý file upload
        let filesData = [];
        if (req.files && req.files.length > 0) {
          const uploadPromises = req.files.map(async (file) => {
            const fileName = `chat_${Date.now()}_${file.originalname}`;
            const fileExt = path.extname(file.originalname).toLowerCase();
            const isMedia = ['.jpeg', '.jpg', '.png', '.mp4', '.mov', '.mp3', '.wav'].includes(fileExt);

            if (isMedia) {
              // Upload media lên Cloudinary
              const resourceType = ['.mp4', '.mov'].includes(fileExt)
                ? 'video'
                : ['.mp3', '.wav'].includes(fileExt)
                ? 'raw'
                : 'image';

              const result = await new Promise((resolve, reject) => {
                cloudinary.uploader.upload_stream(
                  {
                    folder: 'social-network/message',
                    public_id: fileName,
                    resource_type: resourceType
                  },
                  (error, uploadResult) => {
                    if (error) return reject(new Error(`Cloudinary upload failed: ${error.message}`));
                    resolve(uploadResult);
                  }
                ).end(file.buffer);
              });

              return {
                url: result.secure_url,
                key: result.public_id, // Lưu public_id vào key
                name: file.originalname,
                mimeType: file.mimetype,
                size: file.size,
                expiresAt: new Date('4444-04-04') // Ngày hết hạn cố định
              };
            } else {
              // Upload file lên Backblaze B2
              const key = `uploads/${fileName}`;
              const params = {
                Bucket: process.env.B2_BUCKET_NAME,
                Key: key,
                Body: file.buffer,
                ContentType: file.mimetype
              };

              await s3.upload(params).promise();
              const signedUrl = await s3.getSignedUrlPromise('getObject', {
                Bucket: process.env.B2_BUCKET_NAME,
                Key: key,
                Expires: 7 * 24 * 60 * 60 // 7 ngày
              });

              return {
                url: signedUrl,
                key: key,
                name: file.originalname,
                mimeType: file.mimetype,
                size: file.size,
                expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 ngày
              };
            }
          });

          filesData = await Promise.all(uploadPromises);
        }

        // Tạo và lưu tin nhắn
        const message = new Message({
          sender: new mongoose.Types.ObjectId(senderId),
          receiver: new mongoose.Types.ObjectId(receiverId),
          content: content ? content.trim() : '',
          files: filesData,
          createdAt: new Date()
        });

        await message.save();
        await message.populate('sender', 'username avatar');
        await message.populate('receiver', 'username avatar');

        // Xóa cache Redis
        const redisKey = `chat:${[senderId, receiverId].sort().join(':')}`;
        await redisClient.del(redisKey);

        // Emit socket event để thông báo tin nhắn mới
        req.io.to(`user_${receiverId}`).emit('private_message', { message, from: senderId });
        req.io.to(`user_${senderId}`).emit('message_sent', { success: true, message });

        res.json({ success: true, message });
      } catch (error) {
        console.error('Error sending message:', error.stack);
        res.status(500).json({ success: false, error: 'Không thể gửi tin nhắn' });
      }
    }
  ],

  markAsRead: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
      }
      const { messageIds } = req.body;
      const userId = req.session.user._id;
      if (!mongoose.Types.ObjectId.isValid(userId)) {
        console.error('Invalid userId:', userId);
        return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
      }
      if (!messageIds || !Array.isArray(messageIds) || messageIds.length === 0) {
        return res.status(400).json({ success: false, error: 'Danh sách messageIds không hợp lệ' });
      }

      await Message.updateMany(
        { _id: { $in: messageIds }, receiver: new mongoose.Types.ObjectId(userId), isRead: false },
        { isRead: true }
      );

      const redisKeys = await redisClient.keys(`chat:${userId}:*`);
      if (redisKeys.length > 0) {
        await redisClient.del(redisKeys);
      }

      res.json({ success: true, message: 'Đã đánh dấu tin nhắn đã đọc' });
    } catch (error) {
      console.error('Error marking messages as read:', error.stack);
      res.status(500).json({ success: false, error: 'Không thể đánh dấu tin nhắn đã đọc' });
    }
  },

  getUnreadCount: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
      }
      const userId = req.session.user._id;
      if (!mongoose.Types.ObjectId.isValid(userId)) {
        console.error('Invalid userId:', userId);
        return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
      }

      const unreadCounts = await Message.aggregate([
        {
          $match: {
            receiver: new mongoose.Types.ObjectId(userId),
            isRead: false
          }
        },
        {
          $group: {
            _id: '$sender',
            count: { $sum: 1 }
          }
        }
      ]);

      const unreadMap = {};
      unreadCounts.forEach(item => {
        unreadMap[item._id.toString()] = item.count;
      });

      res.json({ success: true, unreadMap });
    } catch (error) {
      console.error('Error getting unread count:', error.stack);
      res.status(500).json({ success: false, error: 'Không thể lấy số tin nhắn chưa đọc' });
    }
  },

  handleSocketConnection: (io) => {
    io.on('connection', (socket) => {
      console.log('User connected:', socket.id);
      socket.on('auth', async (userId) => {
        if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
          console.error('Invalid userId:', userId);
          return;
        }
        try {
          await redisClient.set(`user:${userId}`, socket.id, { EX: 86400 });
          socket.handshake.auth = { userId };
          socket.join(`user_${userId}`);
          console.log(`Stored userId ${userId} in Redis`);
        } catch (err) {
          console.error('Redis set error:', err);
        }
      });

      socket.on('send_message', async (data) => {
        try {
          const { receiverId, senderId } = data;
          if (!mongoose.Types.ObjectId.isValid(senderId) || !mongoose.Types.ObjectId.isValid(receiverId)) {
            console.error('Invalid senderId or receiverId:', { senderId, receiverId });
            socket.emit('message_error', { success: false, error: 'ID không hợp lệ' });
            return;
          }
          console.log(`Forwarding message from ${senderId} to ${receiverId}`);
        } catch (error) {
          console.error('Error handling send_message:', error.stack);
          socket.emit('message_error', { success: false, error: 'Không thể xử lý tin nhắn' });
        }
      });

      socket.on('mark_read', async (data) => {
        try {
          const { senderId, receiverId } = data;
          if (!mongoose.Types.ObjectId.isValid(senderId) || !mongoose.Types.ObjectId.isValid(receiverId)) {
            console.error('Invalid senderId or receiverId:', { senderId, receiverId });
            return;
          }

          await Message.updateMany(
            { sender: new mongoose.Types.ObjectId(senderId), receiver: new mongoose.Types.ObjectId(receiverId), isRead: false },
            { isRead: true }
          );

          io.to(`user_${senderId}`).emit('messages_read', { readBy: receiverId, senderId });
          io.to(`user_${receiverId}`).emit('messages_read', { readBy: receiverId, senderId });
          console.log(`Messages marked as read by ${receiverId} from ${senderId}`);
        } catch (error) {
          console.error('Error marking messages as read:', error.stack);
        }
      });

      socket.on('user_typing', (data) => {
        const { receiverId, isTyping } = data;
        if (!mongoose.Types.ObjectId.isValid(receiverId)) {
          console.error('Invalid receiverId:', receiverId);
          return;
        }
        socket.to(`user_${receiverId}`).emit('user_typing', {
          userId: socket.handshake.auth.userId,
          isTyping
        });
      });

      socket.on('disconnect', async () => {
        if (socket.handshake.auth.userId) {
          await redisClient.del(`user:${socket.handshake.auth.userId}`);
        }
        console.log('User disconnected:', socket.id);
      });
    });
  }
};

module.exports = chatController;

//chatController B2:
const mongoose = require('mongoose');
const Message = require('../models/Message');
const User = require('../models/User');
const redisClient = require('../config/redis');
const s3 = require('../config/backblaze');

const chatController = {
  getChatPage: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        console.error('Session user not found');
        return res.status(401).render('pages/error', {
          message: 'Vui lòng đăng nhập để truy cập trang chat',
          layout: 'layouts/main'
        });
      }
      const userId = req.session.user._id;
      if (!mongoose.Types.ObjectId.isValid(userId)) {
        console.error('Invalid userId:', userId);
        return res.status(400).render('pages/error', {
          message: 'ID người dùng không hợp lệ',
          layout: 'layouts/main'
        });
      }
      console.log('Fetching friends for userId:', userId);
      const friends = await User.find({ _id: { $ne: userId } })
        .select('username avatar')
        .sort({ username: 1 })
        .lean();

      console.log('Fetching unread counts for userId:', userId);
      const unreadCounts = await Message.aggregate([
        {
          $match: {
            receiver: new mongoose.Types.ObjectId(userId),
            isRead: false
          }
        },
        {
          $group: {
            _id: '$sender',
            count: { $sum: 1 }
          }
        }
      ]);

      const unreadMap = {};
      unreadCounts.forEach(item => {
        unreadMap[item._id.toString()] = item.count;
      });

      res.render('pages/chat', {
        title: 'Chat',
        userId,
        friends,
        unreadMap,
        csrfToken: res.locals.csrfToken
      });
    } catch (error) {
      console.error('Error loading chat page:', error.stack);
      res.status(500).render('pages/error', {
        message: 'Không thể tải trang chat',
        layout: 'layouts/main'
      });
    }
  },

  getMessagesWithUser: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
      }
      const userId = req.session.user._id;
      const otherUserId = req.params.userId;
      if (!mongoose.Types.ObjectId.isValid(userId) || !mongoose.Types.ObjectId.isValid(otherUserId)) {
        console.error('Invalid userId or otherUserId:', { userId, otherUserId });
        return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
      }

      const redisKey = `chat:${[userId, otherUserId].sort().join(':')}`;
      const cached = await redisClient.get(redisKey);
      if (cached) {
        return res.json({
          success: true,
          messages: JSON.parse(cached)
        });
      }

      const messages = await Message.find({
        $or: [
          { sender: new mongoose.Types.ObjectId(userId), receiver: new mongoose.Types.ObjectId(otherUserId) },
          { sender: new mongoose.Types.ObjectId(otherUserId), receiver: new mongoose.Types.ObjectId(userId) }
        ]
      })
        .populate('sender', 'username avatar')
        .populate('receiver', 'username avatar')
        .sort({ createdAt: 1 })
        .limit(50);

      await redisClient.setEx(redisKey, 60, JSON.stringify(messages));

      res.json({ success: true, messages });
    } catch (error) {
      console.error('Error fetching messages:', error.stack);
      res.status(500).json({ success: false, error: 'Không thể lấy tin nhắn' });
    }
  },

  sendMessage: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
      }
      const { receiverId, content } = req.body;
      const senderId = req.session.user._id;

      if (!mongoose.Types.ObjectId.isValid(senderId) || !mongoose.Types.ObjectId.isValid(receiverId)) {
        console.error('Invalid senderId or receiverId:', { senderId, receiverId });
        return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
      }

      // Kiểm tra ít nhất phải có content hoặc file
      if ((!content || content.trim() === '') && (!req.files || req.files.length === 0)) {
        return res.status(400).json({ success: false, error: 'Phải cung cấp nội dung hoặc file' });
      }

      // Xử lý file upload lên Backblaze B2
      let filesData = [];
      if (req.files && req.files.length > 0) {
        const uploadPromises = req.files.map(async (file) => {
          const fileName = `chat_${Date.now()}_${file.originalname}`;
          const key = `uploads/${fileName}`;
          const params = {
            Bucket: process.env.B2_BUCKET_NAME,
            Key: key,
            Body: file.buffer,
            ContentType: file.mimetype
          };

          await s3.upload(params).promise();
          const signedUrl = await s3.getSignedUrlPromise('getObject', {
            Bucket: process.env.B2_BUCKET_NAME,
            Key: key,
            Expires: 7 * 24 * 60 * 60 // 7 ngày
          });

          return {
            url: signedUrl,
            key: key,
            name: file.originalname,
            mimeType: file.mimetype,
            size: file.size,
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 ngày
          };
        });

        filesData = await Promise.all(uploadPromises);
      }

      const message = new Message({
        sender: new mongoose.Types.ObjectId(senderId),
        receiver: new mongoose.Types.ObjectId(receiverId),
        content: content ? content.trim() : undefined,
        files: filesData,
        createdAt: new Date()
      });

      await message.save();
      await message.populate('sender', 'username avatar');
      await message.populate('receiver', 'username avatar');

      const redisKey = `chat:${[senderId, receiverId].sort().join(':')}`;
      await redisClient.del(redisKey);

      // Emit socket event để thông báo tin nhắn mới
      req.io.to(`user_${receiverId}`).emit('private_message', { message, from: senderId });
      req.io.to(`user_${senderId}`).emit('message_sent', { success: true, message });

      res.json({ success: true, message });
    } catch (error) {
      console.error('Error sending message:', error.stack);
      res.status(500).json({ success: false, error: 'Không thể gửi tin nhắn' });
    }
  },

  markAsRead: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
      }
      const { messageIds } = req.body;
      const userId = req.session.user._id;
      if (!mongoose.Types.ObjectId.isValid(userId)) {
        console.error('Invalid userId:', userId);
        return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
      }
      if (!messageIds || !Array.isArray(messageIds) || messageIds.length === 0) {
        return res.status(400).json({ success: false, error: 'Danh sách messageIds không hợp lệ' });
      }

      await Message.updateMany(
        { _id: { $in: messageIds }, receiver: new mongoose.Types.ObjectId(userId), isRead: false },
        { isRead: true }
      );

      const redisKeys = await redisClient.keys(`chat:${userId}:*`);
      if (redisKeys.length > 0) {
        await redisClient.del(redisKeys);
      }

      res.json({ success: true, message: 'Đã đánh dấu tin nhắn đã đọc' });
    } catch (error) {
      console.error('Error marking messages as read:', error.stack);
      res.status(500).json({ success: false, error: 'Không thể đánh dấu tin nhắn đã đọc' });
    }
  },

  getUnreadCount: async (req, res) => {
    try {
      if (!req.session.user || !req.session.user._id) {
        return res.status(401).json({ success: false, error: 'Vui lòng đăng nhập' });
      }
      const userId = req.session.user._id;
      if (!mongoose.Types.ObjectId.isValid(userId)) {
        console.error('Invalid userId:', userId);
        return res.status(400).json({ success: false, error: 'ID người dùng không hợp lệ' });
      }

      const unreadCounts = await Message.aggregate([
        {
          $match: {
            receiver: new mongoose.Types.ObjectId(userId),
            isRead: false
          }
        },
        {
          $group: {
            _id: '$sender',
            count: { $sum: 1 }
          }
        }
      ]);

      const unreadMap = {};
      unreadCounts.forEach(item => {
        unreadMap[item._id.toString()] = item.count;
      });

      res.json({ success: true, unreadMap });
    } catch (error) {
      console.error('Error getting unread count:', error.stack);
      res.status(500).json({ success: false, error: 'Không thể lấy số tin nhắn chưa đọc' });
    }
  },

  handleSocketConnection: (io) => {
    io.on('connection', (socket) => {
      console.log('User connected:', socket.id);
      socket.on('auth', async (userId) => {
        if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
          console.error('Invalid userId:', userId);
          return;
        }
        try {
          await redisClient.set(`user:${userId}`, socket.id, { EX: 86400 });
          socket.handshake.auth = { userId };
          socket.join(`user_${userId}`);
          console.log(`Stored userId ${userId} in Redis`);
        } catch (err) {
          console.error('Redis set error:', err);
        }
      });

      socket.on('send_message', async (data) => {
        try {
          const { receiverId, senderId } = data;
          if (!mongoose.Types.ObjectId.isValid(senderId) || !mongoose.Types.ObjectId.isValid(receiverId)) {
            console.error('Invalid senderId or receiverId:', { senderId, receiverId });
            socket.emit('message_error', { success: false, error: 'ID không hợp lệ' });
            return;
          }
          // Tin nhắn đã được lưu trong HTTP request, chỉ emit thông báo
          console.log(`Forwarding message from ${senderId} to ${receiverId}`);
        } catch (error) {
          console.error('Error handling send_message:', error.stack);
          socket.emit('message_error', { success: false, error: 'Không thể xử lý tin nhắn' });
        }
      });

      socket.on('mark_read', async (data) => {
        try {
          const { senderId, receiverId } = data;
          if (!mongoose.Types.ObjectId.isValid(senderId) || !mongoose.Types.ObjectId.isValid(receiverId)) {
            console.error('Invalid senderId or receiverId:', { senderId, receiverId });
            return;
          }

          await Message.updateMany(
            { sender: new mongoose.Types.ObjectId(senderId), receiver: new mongoose.Types.ObjectId(receiverId), isRead: false },
            { isRead: true }
          );

          io.to(`user_${senderId}`).emit('messages_read', { readBy: receiverId, senderId });
          io.to(`user_${receiverId}`).emit('messages_read', { readBy: receiverId, senderId });
          console.log(`Messages marked as read by ${receiverId} from ${senderId}`);
        } catch (error) {
          console.error('Error marking messages as read:', error.stack);
        }
      });

      socket.on('user_typing', (data) => {
        const { receiverId, isTyping } = data;
        if (!mongoose.Types.ObjectId.isValid(receiverId)) {
          console.error('Invalid receiverId:', receiverId);
          return;
        }
        socket.to(`user_${receiverId}`).emit('user_typing', {
          userId: socket.handshake.auth.userId,
          isTyping
        });
      });

      socket.on('disconnect', async () => {
        if (socket.handshake.auth.userId) {
          await redisClient.del(`user:${socket.handshake.auth.userId}`);
        }
        console.log('User disconnected:', socket.id);
      });
    });
  }
};

module.exports = chatController;

***((((((((((()))))))))))

  //
   <!-- Add Story
    <div class="mb-6">
      <h2 class="text-lg font-bold mb-2">Câu chuyện</h2>
      <div class="flex space-x-4 overflow-x-auto">
        <div class="flex-shrink-0 w-24 h-32 bg-gray-200 rounded-lg flex items-center justify-center">
          <button class="bg-blue-500 text-white px-2 py-1 rounded">Thêm câu chuyện</button>
        </div>
        <div class="flex-shrink-0 w-24 h-32 bg-gray-300 rounded-lg"></div>
        <div class="flex-shrink-0 w-24 h-32 bg-gray-400 rounded-lg"></div>
        <div class="flex-shrink-0 w-24 h-32 bg-gray-500 rounded-lg"></div>
      </div>
    </div> -->


// Log session Redis
app.use(async (req, res, next) => {
  if (req.session?.user) {
    try {
      const sessionId = req.sessionID;
      const sessionData = await redisClient.get(`sess:${sessionId}`);
      console.log(`[Redis session] sess:${sessionId} => ${sessionData ? 'Found' : 'Not found'}`);
    } catch (err) {
      console.error('[Redis session] Error:', err.message);
    }
  }
  next();
});

// Log POST request sau khi parse
app.use((req, res, next) => {
  if (req.method === 'POST') {
    console.log('POST Request Headers:', {
      'content-type': req.headers['content-type'],
      'content-length': req.headers['content-length']
    });
    console.log('POST Request Body:', req.body);
  }
  next();
});

// Xử lý lỗi CSRF
app.use((err, req, res, next) => {
  if (err.code === 'EBADCSRFTOKEN') {
    console.error('CSRF Error:', err);
    console.log('Session ID:', req.sessionID);
    console.log('Session Data:', req.session);
    console.log('CSRF Token Expected:', req.csrfToken ? req.csrfToken() : 'Not available');
    console.log('CSRF Token Received:', req.body ? req.body._csrf : 'Not available');
    return res.status(403).render('pages/error', {
      message: 'Invalid CSRF token. Please refresh the page and try again.',
      user: req.session.user,
      layout: 'layouts/main'
    });
  }
  next(err);
});

// Xử lý lỗi Multer và uploadMedia
app.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    console.error('Multer Error:', err);
    return res.status(400).render('pages/error', {
      message: `Multer error: ${err.message}`,
      user: req.session.user,
      layout: 'layouts/main'
    });
  }
  if (err.message === 'Only images (JPEG, PNG), videos (MP4, MOV), and audio (MP3, WAV) are allowed') {
    console.error('File Type Error:', err);
    return res.status(400).render('pages/home', {
      posts: [],
      user: req.session.user,
      csrfToken: res.locals.csrfToken,
      errors: [{ msg: err.message }],
      title: 'Home',
      layout: 'layouts/main'
    });
  }
  if (err.message === 'Only JPEG and PNG images are allowed') {
    console.error('File Type Error:', err);
    return res.status(400).render('pages/edit-profile', {
      user: req.session.user,
      errors: [{ msg: err.message }],
      csrfToken: res.locals.csrfToken,
      title: 'Edit Profile',
      layout: 'layouts/main'
    });
  }
  next(err);
});

//Chat
app.use(async (req, res, next) => {
  try {
    res.locals.csrfToken = req.csrfToken ? req.csrfToken() : '';
  } catch (err) {
    res.locals.csrfToken = '';
  }

  res.locals.currentUser = req.session.user || null;
  res.locals.user = res.locals.user;
  res.locals.friendId = null;
  res.locals.unreadMap = {};

  if (req.session.user && req.session.user._id) {
    console.log('[Session] User ID:', req.session.user._id); // Debug
    try {
      const user = await User.findById(req.session.user._id)
        .populate('friends', 'username avatar') 
        .lean();

      res.locals.friends = user.friends || [];

      const unreadCounts = await Message.aggregate([
        {
          $match: {
            receiver: mongoose.Types.ObjectId(req.session.user._id),
            isRead: false
          }
        },
        {
          $group: {
            _id: '$sender',
            count: { $sum: 1 }
          }
        }
      ]);

      unreadCounts.forEach(item => {
        res.locals.unreadMap[item._id.toString()] = item.count;
      });
    } catch (err) {
      console.error('Error fetching friends or unread messages:', err.message);
    }
  } else {
    console.log('[Session] No user session found'); // Debug
  }

  next();
});

//
console.log('User connected:', socket.id);

  socket.on('private_message', async (data) => {
    const { sender, receiver, content } = data;
    const newMsg = new Message({ sender, receiver, content });
    await newMsg.save();

    socket.to(receiver).emit('private_message', { sender, content });

    // Gửi về cho người nhận (nếu đang online)
    io.sockets.sockets.forEach((s) => {
      if (s.handshake.auth.userId === receiver) {
        s.emit('private_message', { sender, content });
      }
    });
  });
  
  // Lưu userId để gửi đúng người
  socket.on('auth', (userId) => {
    socket.handshake.auth = { userId };
  });

  //chat-modal.js:
  socket.on('private_message', ({ message, from }) => {
  if (from === currentChatUserId) {
    const chatBox = document.getElementById('chatMessages');
    const div = document.createElement('div');
    div.className = 'text-left';
    div.innerHTML = `<div class="inline-block px-3 py-2 m-1 rounded bg-gray-200"><p>${message.content}</p></div>`;
    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;
  }
});